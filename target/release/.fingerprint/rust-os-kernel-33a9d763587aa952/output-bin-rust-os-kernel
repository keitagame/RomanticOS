{"$message_type":"diagnostic","message":"unused import: `alloc::boxed::Box`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/process.rs","byte_start":77,"byte_end":94,"line_start":6,"line_end":6,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/process.rs","byte_start":73,"byte_end":96,"line_start":6,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":23},{"text":"use spin::Mutex;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `alloc::boxed::Box`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/process.rs:6:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use alloc::boxed::Box;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `x86_64::structures::idt::InterruptStackFrame`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":4,"byte_end":48,"line_start":1,"line_end":1,"column_start":5,"column_end":49,"is_primary":true,"text":[{"text":"use x86_64::structures::idt::InterruptStackFrame;","highlight_start":5,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":0,"byte_end":50,"line_start":1,"line_end":2,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use x86_64::structures::idt::InterruptStackFrame;","highlight_start":1,"highlight_end":50},{"text":"use spin::Mutex;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `x86_64::structures::idt::InterruptStackFrame`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:1:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use x86_64::structures::idt::InterruptStackFrame;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `alloc::boxed::Box`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/filesystem.rs","byte_start":66,"byte_end":83,"line_start":4,"line_end":4,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/filesystem.rs","byte_start":62,"byte_end":85,"line_start":4,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::boxed::Box;","highlight_start":1,"highlight_end":23},{"text":"use spin::Mutex;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `alloc::boxed::Box`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/filesystem.rs:4:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use alloc::boxed::Box;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `read_volatile`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/drivers/vga.rs","byte_start":90,"byte_end":103,"line_start":4,"line_end":4,"column_start":33,"column_end":46,"is_primary":true,"text":[{"text":"use core::ptr::{write_volatile, read_volatile};","highlight_start":33,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/drivers/vga.rs","byte_start":88,"byte_end":103,"line_start":4,"line_end":4,"column_start":31,"column_end":46,"is_primary":true,"text":[{"text":"use core::ptr::{write_volatile, read_volatile};","highlight_start":31,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/drivers/vga.rs","byte_start":73,"byte_end":74,"line_start":4,"line_end":4,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"use core::ptr::{write_volatile, read_volatile};","highlight_start":16,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/drivers/vga.rs","byte_start":103,"byte_end":104,"line_start":4,"line_end":4,"column_start":46,"column_end":47,"is_primary":true,"text":[{"text":"use core::ptr::{write_volatile, read_volatile};","highlight_start":46,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `read_volatile`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/drivers/vga.rs:4:33\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use core::ptr::{write_volatile, read_volatile};\n  \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/memory.rs","byte_start":3747,"byte_end":3757,"line_start":118,"line_end":118,"column_start":31,"column_end":41,"is_primary":true,"text":[{"text":"        ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);","highlight_start":31,"highlight_end":41}],"label":"expected `*mut u8`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/memory.rs","byte_start":3742,"byte_end":3746,"line_start":118,"line_end":118,"column_start":26,"column_end":30,"is_primary":false,"text":[{"text":"        ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);","highlight_start":26,"highlight_end":30}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected raw pointer `*mut u8`\n          found type `usize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linked_list_allocator-0.10.5/src/lib.rs","byte_start":2596,"byte_end":2600,"line_start":90,"line_end":90,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"    pub unsafe fn init(&mut self, heap_bottom: *mut u8, heap_size: usize) {","highlight_start":19,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/memory.rs:118:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `*mut u8`, found `usize`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected raw pointer `\u001b[1m\u001b[35m*mut u8\u001b[0m`\n                      found type `\u001b[1m\u001b[35musize\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/linked_list_allocator-0.10.5/src/lib.rs:90:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub unsafe fn init(&mut self, heap_bottom: *mut u8, heap_size: usize) {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[92m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed for `x86_64::structures::paging::Page<_>`","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src/memory.rs","byte_start":5006,"byte_end":5010,"line_start":158,"line_end":158,"column_start":26,"column_end":30,"is_primary":false,"text":[{"text":"        let start_page = Page::containing_address(addr);","highlight_start":26,"highlight_end":30}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/memory.rs","byte_start":4993,"byte_end":5003,"line_start":158,"line_end":158,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let start_page = Page::containing_address(addr);","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"cannot satisfy `_: PageSize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following types implement trait `PageSize`","code":null,"level":"help","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/x86_64-0.14.13/src/structures/paging/page.rs","byte_start":1471,"byte_end":1497,"line_start":52,"line_end":52,"column_start":1,"column_end":27,"is_primary":true,"text":[{"text":"impl PageSize for Size1GiB {","highlight_start":1,"highlight_end":27}],"label":"`x86_64::structures::paging::Size1GiB`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/x86_64-0.14.13/src/structures/paging/page.rs","byte_start":1304,"byte_end":1330,"line_start":45,"line_end":45,"column_start":1,"column_end":27,"is_primary":true,"text":[{"text":"impl PageSize for Size2MiB {","highlight_start":1,"highlight_end":27}],"label":"`x86_64::structures::paging::Size2MiB`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/x86_64-0.14.13/src/structures/paging/page.rs","byte_start":1153,"byte_end":1179,"line_start":38,"line_end":38,"column_start":1,"column_end":27,"is_primary":true,"text":[{"text":"impl PageSize for Size4KiB {","highlight_start":1,"highlight_end":27}],"label":"`x86_64::structures::paging::Size4KiB`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `x86_64::structures::paging::Page`","code":null,"level":"note","spans":[{"file_name":"/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/x86_64-0.14.13/src/structures/paging/page.rs","byte_start":1717,"byte_end":1725,"line_start":60,"line_end":60,"column_start":20,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Page<S: PageSize = Size4KiB> {","highlight_start":20,"highlight_end":28}],"label":"required by this bound in `Page`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider giving `start_page` an explicit type, where the type for type parameter `S` is specified","code":null,"level":"help","spans":[{"file_name":"src/memory.rs","byte_start":5003,"byte_end":5003,"line_start":158,"line_end":158,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let start_page = Page::containing_address(addr);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": x86_64::structures::paging::Page<S>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0283]\u001b[0m\u001b[1m: type annotations needed for `x86_64::structures::paging::Page<_>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/memory.rs:158:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let start_page = Page::containing_address(addr);\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: cannot satisfy `_: PageSize`\n\u001b[1m\u001b[96mhelp\u001b[0m: the following types implement trait `PageSize`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/x86_64-0.14.13/src/structures/paging/page.rs:38:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl PageSize for Size4KiB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`x86_64::structures::paging::Size4KiB`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl PageSize for Size2MiB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`x86_64::structures::paging::Size2MiB`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m 52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl PageSize for Size1GiB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m`x86_64::structures::paging::Size1GiB`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `x86_64::structures::paging::Page`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/x86_64-0.14.13/src/structures/paging/page.rs:60:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m 60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Page<S: PageSize = Size4KiB> {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Page`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `start_page` an explicit type, where the type for type parameter `S` is specified\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let start_page\u001b[92m: x86_64::structures::paging::Page<S>\u001b[0m = Page::containing_address(addr);\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed for `x86_64::structures::paging::Page<_>`","code":{"code":"E0283","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0283\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nWe can see a self-contained example below:\n\n```compile_fail,E0283\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = foo.into() * 1u32;\n```\n\nThis error can be solved by adding type annotations that provide the missing\ninformation to the compiler. In this case, the solution is to specify the\ntrait's type parameter:\n\n```\nstruct Foo;\n\nimpl Into<u32> for Foo {\n    fn into(self) -> u32 { 1 }\n}\n\nlet foo = Foo;\nlet bar: u32 = Into::<u32>::into(foo) * 1u32;\n```\n"},"level":"error","spans":[{"file_name":"src/memory.rs","byte_start":5178,"byte_end":5182,"line_start":162,"line_end":162,"column_start":58,"column_end":62,"is_primary":false,"text":[{"text":"            if let Ok((_, flush)) = manager.mapper.unmap(page) {","highlight_start":58,"highlight_end":62}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/memory.rs","byte_start":5172,"byte_end":5177,"line_start":162,"line_end":162,"column_start":52,"column_end":57,"is_primary":false,"text":[{"text":"            if let Ok((_, flush)) = manager.mapper.unmap(page) {","highlight_start":52,"highlight_end":57}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/memory.rs","byte_start":4993,"byte_end":5003,"line_start":158,"line_end":158,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let start_page = Page::containing_address(addr);","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"multiple `impl`s satisfying `OffsetPageTable<'static>: Mapper<_>` found in the `x86_64` crate:\n- impl<'a> Mapper<x86_64::structures::paging::Size1GiB> for OffsetPageTable<'a>;\n- impl<'a> Mapper<x86_64::structures::paging::Size2MiB> for OffsetPageTable<'a>;\n- impl<'a> Mapper<x86_64::structures::paging::Size4KiB> for OffsetPageTable<'a>;","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider giving `start_page` an explicit type, where the type for type parameter `S` is specified","code":null,"level":"help","spans":[{"file_name":"src/memory.rs","byte_start":5003,"byte_end":5003,"line_start":158,"line_end":158,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let start_page = Page::containing_address(addr);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": x86_64::structures::paging::Page<S>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0283]\u001b[0m\u001b[1m: type annotations needed for `x86_64::structures::paging::Page<_>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/memory.rs:158:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let start_page = Page::containing_address(addr);\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m162\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Ok((_, flush)) = manager.mapper.unmap(page) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: multiple `impl`s satisfying `OffsetPageTable<'static>: Mapper<_>` found in the `x86_64` crate:\n            - impl<'a> Mapper<x86_64::structures::paging::Size1GiB> for OffsetPageTable<'a>;\n            - impl<'a> Mapper<x86_64::structures::paging::Size2MiB> for OffsetPageTable<'a>;\n            - impl<'a> Mapper<x86_64::structures::paging::Size4KiB> for OffsetPageTable<'a>;\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `start_page` an explicit type, where the type for type parameter `S` is specified\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let start_page\u001b[92m: x86_64::structures::paging::Page<S>\u001b[0m = Page::containing_address(addr);\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Option<Inode>: Clone` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/filesystem.rs","byte_start":1862,"byte_end":1866,"line_start":87,"line_end":87,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"            inodes: vec![None; 1024],","highlight_start":26,"highlight_end":30}],"label":"the trait `Clone` is not implemented for `Option<Inode>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1540,"byte_end":1562,"line_start":47,"line_end":47,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":9,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/filesystem.rs","byte_start":1857,"byte_end":1873,"line_start":87,"line_end":87,"column_start":21,"column_end":37,"is_primary":false,"text":[{"text":"            inodes: vec![None; 1024],","highlight_start":21,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1431,"byte_end":1447,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `Option<Inode>` to implement `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `alloc::vec::from_elem`","code":null,"level":"note","spans":[{"file_name":"/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs","byte_start":133754,"byte_end":133759,"line_start":3585,"line_end":3585,"column_start":21,"column_end":26,"is_primary":true,"text":[{"text":"pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {","highlight_start":21,"highlight_end":26}],"label":"required by this bound in `from_elem`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"src/filesystem.rs","byte_start":1862,"byte_end":1862,"line_start":87,"line_end":87,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            inodes: vec![None; 1024],","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Option<Inode>: Clone` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/filesystem.rs:87:26\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             inodes: vec![None; 1024],\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-----\u001b[0m\u001b[1m\u001b[91m^^^^\u001b[0m\u001b[1m\u001b[94m-------\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m|\u001b[0m    \u001b[1m\u001b[91m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m|\u001b[0m    \u001b[1m\u001b[91mthe trait `Clone` is not implemented for `Option<Inode>`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Option<Inode>` to implement `Clone`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `alloc::vec::from_elem`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3585:21\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3585\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `from_elem`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  87\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            inodes: vec![\u001b[92m&\u001b[0mNone; 1024],\n     \u001b[1m\u001b[94m|\u001b[0m                          \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Option<OpenFile>: Clone` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/filesystem.rs","byte_start":1904,"byte_end":1908,"line_start":88,"line_end":88,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"            open_files: vec![None; MAX_OPEN_FILES],","highlight_start":30,"highlight_end":34}],"label":"the trait `Clone` is not implemented for `Option<OpenFile>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1540,"byte_end":1562,"line_start":47,"line_end":47,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        $crate::vec::from_elem($elem, $n)","highlight_start":9,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/filesystem.rs","byte_start":1899,"byte_end":1925,"line_start":88,"line_end":88,"column_start":25,"column_end":51,"is_primary":false,"text":[{"text":"            open_files: vec![None; MAX_OPEN_FILES],","highlight_start":25,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/macros.rs","byte_start":1431,"byte_end":1447,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"macro_rules! vec {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `Option<OpenFile>` to implement `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `alloc::vec::from_elem`","code":null,"level":"note","spans":[{"file_name":"/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs","byte_start":133754,"byte_end":133759,"line_start":3585,"line_end":3585,"column_start":21,"column_end":26,"is_primary":true,"text":[{"text":"pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {","highlight_start":21,"highlight_end":26}],"label":"required by this bound in `from_elem`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"src/filesystem.rs","byte_start":1904,"byte_end":1904,"line_start":88,"line_end":88,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"            open_files: vec![None; MAX_OPEN_FILES],","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Option<OpenFile>: Clone` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/filesystem.rs:88:30\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             open_files: vec![None; MAX_OPEN_FILES],\n     \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94m-----\u001b[0m\u001b[1m\u001b[91m^^^^\u001b[0m\u001b[1m\u001b[94m-----------------\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94m|\u001b[0m    \u001b[1m\u001b[91m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94m|\u001b[0m    \u001b[1m\u001b[91mthe trait `Clone` is not implemented for `Option<OpenFile>`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Option<OpenFile>` to implement `Clone`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `alloc::vec::from_elem`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/codespace/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3585:21\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3585\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `from_elem`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m  88\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            open_files: vec![\u001b[92m&\u001b[0mNone; MAX_OPEN_FILES],\n     \u001b[1m\u001b[94m|\u001b[0m                              \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unreachable expression","code":{"code":"unreachable_code","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1650,"byte_end":1699,"line_start":73,"line_end":75,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    loop {","highlight_start":5,"highlight_end":11},{"text":"        x86_64::instructions::hlt();","highlight_start":1,"highlight_end":37},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"unreachable expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1581,"byte_end":1608,"line_start":70,"line_end":70,"column_start":5,"column_end":32,"is_primary":false,"text":[{"text":"    process::scheduler::start();","highlight_start":5,"highlight_end":32}],"label":"any code following this expression is unreachable","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unreachable expression\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:73:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       process::scheduler::start();\n   \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94many code following this expression is unreachable\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m/\u001b[0m     loop {\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m         x86_64::instructions::hlt();\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|\u001b[0m     }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[33m|_____^\u001b[0m \u001b[1m\u001b[33munreachable expression\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/memory.rs","byte_start":2076,"byte_end":2087,"line_start":67,"line_end":67,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    let mut manager = MemoryManager {","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/memory.rs","byte_start":2076,"byte_end":2080,"line_start":67,"line_end":67,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    let mut manager = MemoryManager {","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/memory.rs:67:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut manager = MemoryManager {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m----\u001b[0m\u001b[1m\u001b[33m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94mhelp: remove this `mut`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `count`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/memory.rs","byte_start":4518,"byte_end":4523,"line_start":147,"line_end":147,"column_start":20,"column_end":25,"is_primary":true,"text":[{"text":"fn find_free_pages(count: usize) -> Option<Page> {","highlight_start":20,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/memory.rs","byte_start":4518,"byte_end":4523,"line_start":147,"line_end":147,"column_start":20,"column_end":25,"is_primary":true,"text":[{"text":"fn find_free_pages(count: usize) -> Option<Page> {","highlight_start":20,"highlight_end":25}],"label":null,"suggested_replacement":"_count","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `count`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/memory.rs:147:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn find_free_pages(count: usize) -> Option<Page> {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[33m^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_count`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/process.rs","byte_start":1712,"byte_end":1728,"line_start":84,"line_end":84,"column_start":13,"column_end":29,"is_primary":true,"text":[{"text":"        let mut kernel_stack = vec![0u8; 8192]; // 8KB カーネルスタック","highlight_start":13,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/process.rs","byte_start":1712,"byte_end":1716,"line_start":84,"line_end":84,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"        let mut kernel_stack = vec![0u8; 8192]; // 8KB カーネルスタック","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/process.rs:84:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut kernel_stack = vec![0u8; 8192]; // 8KB カーネルスタック\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m----\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.processes` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/process.rs","byte_start":4008,"byte_end":4022,"line_start":164,"line_end":164,"column_start":36,"column_end":50,"is_primary":true,"text":[{"text":"            if let Some(process) = self.processes.iter_mut().find(|p| p.pid == pid) {","highlight_start":36,"highlight_end":50}],"label":"`self.processes` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/process.rs","byte_start":3338,"byte_end":3339,"line_start":144,"line_end":144,"column_start":21,"column_end":22,"is_primary":false,"text":[{"text":"    pub fn schedule(&mut self) -> Option<&mut Process> {","highlight_start":21,"highlight_end":22}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/process.rs","byte_start":4253,"byte_end":4266,"line_start":168,"line_end":168,"column_start":28,"column_end":41,"is_primary":false,"text":[{"text":"                    return Some(process);","highlight_start":28,"highlight_end":41}],"label":"returning this value requires that `self.processes` is borrowed for `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `self.processes` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/process.rs:164:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn schedule(&mut self) -> Option<&mut Process> {\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some(process) = self.processes.iter_mut().find(|p| p.pid == pid) {\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.processes` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     return Some(process);\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mreturning this value requires that `self.processes` is borrowed for `'1`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `code`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/process.rs","byte_start":6721,"byte_end":6725,"line_start":256,"line_end":256,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"pub fn exit(code: i32) {","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/process.rs","byte_start":6721,"byte_end":6725,"line_start":256,"line_end":256,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"pub fn exit(code: i32) {","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"_code","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `code`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/process.rs:256:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m256\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn exit(code: i32) {\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_code`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `argv`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":4647,"byte_end":4651,"line_start":168,"line_end":168,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"fn sys_execve(filename: *const u8, argv: *const *const u8, envp: *const *const u8) -> i64 {","highlight_start":36,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":4647,"byte_end":4651,"line_start":168,"line_end":168,"column_start":36,"column_end":40,"is_primary":true,"text":[{"text":"fn sys_execve(filename: *const u8, argv: *const *const u8, envp: *const *const u8) -> i64 {","highlight_start":36,"highlight_end":40}],"label":null,"suggested_replacement":"_argv","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `argv`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:168:36\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_execve(filename: *const u8, argv: *const *const u8, envp: *const *const u8) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_argv`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `envp`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":4671,"byte_end":4675,"line_start":168,"line_end":168,"column_start":60,"column_end":64,"is_primary":true,"text":[{"text":"fn sys_execve(filename: *const u8, argv: *const *const u8, envp: *const *const u8) -> i64 {","highlight_start":60,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":4671,"byte_end":4675,"line_start":168,"line_end":168,"column_start":60,"column_end":64,"is_primary":true,"text":[{"text":"fn sys_execve(filename: *const u8, argv: *const *const u8, envp: *const *const u8) -> i64 {","highlight_start":60,"highlight_end":64}],"label":null,"suggested_replacement":"_envp","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `envp`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:168:60\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_execve(filename: *const u8, argv: *const *const u8, envp: *const *const u8) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m                                                            \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_envp`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `addr`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":5255,"byte_end":5259,"line_start":195,"line_end":195,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":5255,"byte_end":5259,"line_start":195,"line_end":195,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":"_addr","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `addr`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:195:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_addr`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `prot`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":5281,"byte_end":5285,"line_start":195,"line_end":195,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":39,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":5281,"byte_end":5285,"line_start":195,"line_end":195,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":39,"highlight_end":43}],"label":null,"suggested_replacement":"_prot","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `prot`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:195:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[33m^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_prot`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `flags`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":5292,"byte_end":5297,"line_start":195,"line_end":195,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":50,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":5292,"byte_end":5297,"line_start":195,"line_end":195,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":50,"highlight_end":55}],"label":null,"suggested_replacement":"_flags","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `flags`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:195:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[33m^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_flags`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `fd`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":5304,"byte_end":5306,"line_start":195,"line_end":195,"column_start":62,"column_end":64,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":62,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":5304,"byte_end":5306,"line_start":195,"line_end":195,"column_start":62,"column_end":64,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":62,"highlight_end":64}],"label":null,"suggested_replacement":"_fd","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `fd`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:195:62\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[33m^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_fd`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `offset`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/syscall.rs","byte_start":5313,"byte_end":5319,"line_start":195,"line_end":195,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/syscall.rs","byte_start":5313,"byte_end":5319,"line_start":195,"line_end":195,"column_start":71,"column_end":77,"is_primary":true,"text":[{"text":"fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {","highlight_start":71,"highlight_end":77}],"label":null,"suggested_replacement":"_offset","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `offset`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syscall.rs:195:71\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn sys_mmap(addr: u64, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> i64 {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                       \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_offset`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `color_code`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/drivers/vga.rs","byte_start":1590,"byte_end":1600,"line_start":74,"line_end":74,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"                let color_code = self.color_code;","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/drivers/vga.rs","byte_start":1590,"byte_end":1600,"line_start":74,"line_end":74,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"                let color_code = self.color_code;","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":"_color_code","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `color_code`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/drivers/vga.rs:74:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let color_code = self.color_code;\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_color_code`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/interrupts.rs","byte_start":3318,"byte_end":3333,"line_start":123,"line_end":123,"column_start":53,"column_end":68,"is_primary":true,"text":[{"text":"extern \"x86-interrupt\" fn syscall_interrupt_handler(mut stack_frame: InterruptStackFrame) {","highlight_start":53,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/interrupts.rs","byte_start":3318,"byte_end":3322,"line_start":123,"line_end":123,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"extern \"x86-interrupt\" fn syscall_interrupt_handler(mut stack_frame: InterruptStackFrame) {","highlight_start":53,"highlight_end":57}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/interrupts.rs:123:53\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m extern \"x86-interrupt\" fn syscall_interrupt_handler(mut stack_frame: InterruptStackFrame) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[94m----\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[94mhelp: remove this `mut`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `stack_frame`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/interrupts.rs","byte_start":3318,"byte_end":3333,"line_start":123,"line_end":123,"column_start":53,"column_end":68,"is_primary":true,"text":[{"text":"extern \"x86-interrupt\" fn syscall_interrupt_handler(mut stack_frame: InterruptStackFrame) {","highlight_start":53,"highlight_end":68}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/interrupts.rs","byte_start":3318,"byte_end":3333,"line_start":123,"line_end":123,"column_start":53,"column_end":68,"is_primary":true,"text":[{"text":"extern \"x86-interrupt\" fn syscall_interrupt_handler(mut stack_frame: InterruptStackFrame) {","highlight_start":53,"highlight_end":68}],"label":null,"suggested_replacement":"_stack_frame","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `stack_frame`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/interrupts.rs:123:53\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m extern \"x86-interrupt\" fn syscall_interrupt_handler(mut stack_frame: InterruptStackFrame) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_stack_frame`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 6 previous errors; 19 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 6 previous errors; 19 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0283, E0308, E0499.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0283, E0308, E0499.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
